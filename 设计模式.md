# 设计模式
## 组合模式
组合模式是一种结构型设计模式，用于将对象组合成树形结构以表示部分-整体层次关系。它使得客户端可以统一对待单个对象和组合对象，从而简化了客户端代码。

### 结构

1. **Component（组件）**：
   - 定义组合中所有对象的通用接口，包括叶子节点和容器节点。
   - 声明了在组合结构中处理组件的方法，通常包括添加、删除、获取子组件等方法。

2. **Leaf（叶子）**：
   - 表示组合中的叶子节点对象，它没有子节点。
   - 实现了在组合结构中定义的共享接口。

3. **Composite（容器）**：
   - 表示组合中的容器节点对象，它可以包含子节点。
   - 实现了在组合结构中定义的共享接口，并在内部管理子组件。

### 优点

- **简化客户端代码**：客户端可以一致地对待单个对象和组合对象，无需关心对象的具体类型。
- **灵活性**：可以通过组合的方式构建出复杂的树形结构，并且可以动态地添加、删除子组件。
- **单一责任原则**：每个对象都有自己的职责，叶子节点负责具体的操作，容器节点负责管理子组件。

### 适用场景

- 当需要表示对象的部分-整体层次关系，并且希望客户端能够统一对待单个对象和组合对象时，可以考虑使用组合模式。
- 当希望简化客户端代码，并且能够动态地构建出复杂的对象结构时，也适合使用组合模式。

### 示例

考虑一个文件系统的例子，其中文件和文件夹都是对象。文件夹可以包含文件和其他文件夹，而文件是叶子节点，不能再包含其他对象。使用组合模式可以轻松地表示文件系统的层次结构，并且可以统一对待文件和文件夹对象。

```cpp
#include <iostream>
#include <vector>
#include <memory>

// 组件接口
class FileSystemComponent {
public:
    virtual void display() const = 0;
};

// 叶子节点：文件
class File : public FileSystemComponent {
public:
    File(std::string name) : name(name) {}

    void display() const override {
        std::cout << "File: " << name << std::endl;
    }

private:
    std::string name;
};

// 容器节点：文件夹
class Folder : public FileSystemComponent {
public:
    void addComponent(std::shared_ptr<FileSystemComponent> component) {
        components.push_back(component);
    }

    void display() const override {
        std::cout << "Folder" << std::endl;
        for (auto& component : components) {
            component->display();
        }
    }

private:
    std::vector<std::shared_ptr<FileSystemComponent>> components;
};

int main() {
    // 创建文件系统
    std::shared_ptr<Folder> rootFolder = std::make_shared<Folder>();
    std::shared_ptr<File> file1 = std::make_shared<File>("file1.txt");
    std::shared_ptr<File> file2 = std::make_shared<File>("file2.txt");
    std::shared_ptr<Folder> subFolder = std::make_shared<Folder>();

    // 构建文件系统结构
    rootFolder->addComponent(file1);
    rootFolder->addComponent(file2);
    rootFolder->addComponent(subFolder);
    subFolder->addComponent(std::make_shared<File>("subFile.txt"));

    // 显示文件系统
    rootFolder->display();

    return 0;
}
```

在此示例中，`FileSystemComponent` 是组件的抽象接口，`File` 是叶子节点，`Folder` 是容器节点。通过组合 `File` 和 `Folder` 对象，可以构建出复杂的文件系统结构，并且可以统一对待文件和文件夹对象。


**补充**
意图：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。

关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。

优点： 1、高层模块调用简单。 2、节点自由增加。

缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。

注意事项：定义时为具体类。

组合模式的核心角色包括：

组件（Component）:

定义了组合中所有对象的通用接口，可以是抽象类或接口。它声明了用于访问和管理子组件的方法，包括添加、删除、获取子组件等。
叶子节点（Leaf）:

表示组合中的叶子节点对象，叶子节点没有子节点。它实现了组件接口的方法，但通常不包含子组件。
复合节点（Composite）:

表示组合中的复合对象，复合节点可以包含子节点，可以是叶子节点，也可以是其他复合节点。它实现了组件接口的方法，包括管理子组件的方法。
客户端（Client）:

通过组件接口与组合结构进行交互，客户端不需要区分叶子节点和复合节点，可以一致地对待整体和部分。


## 桥接模式

**桥接模式**
桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。

桥接模式的目的是将抽象与实现分离，使它们可以独立地变化，该模式通过将一个对象的抽象部分与它的实现部分分离，使它们可以独立地改变。它通过组合的方式，而不是继承的方式，将抽象和实现的部分连接起来。

我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。

介绍
意图：将抽象部分与实现部分分离，使它们都可以独立的变化。

主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。

如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

关键代码：抽象类依赖实现类。

应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。

以下是桥接模式的几个关键角色：

抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。
扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。
实现（Implementor）：定义实现接口，提供基本操作的接口。
具体实现（Concrete Implementor）：实现实现接口的具体类。

****************************************************************

桥接模式是一种结构型设计模式，用于将抽象部分与其实现部分分离，使它们可以独立地变化。这种模式通过创建桥接接口（Bridge Interface）来连接抽象类和实现类，从而允许它们在运行时独立地变化。

### 主要角色：

1. **抽象类（Abstraction）**：定义抽象部分的接口，并维护对实现部分的引用。通常，它包含一个成员变量，该变量是桥接接口类型的指针，并在其方法中使用该接口来委托实际工作。

2. **实现类接口（Implementor Interface）**：定义实现部分的接口，供具体的实现类实现。

3. **具体实现类（Concrete Implementor）**：实现实现类接口的具体类。

4. **扩充抽象类（Refined Abstraction）**：对抽象类的扩展，通常提供更高级别的接口。

### 桥接模式的优点：

- **解耦性（Decoupling）**：将抽象部分和实现部分分离，使它们可以独立地变化，从而降低了它们之间的耦合度。
  
- **灵活性（Flexibility）**：可以在运行时动态地选择实现，而无需修改客户端代码。

- **可扩展性（Scalability）**：通过增加新的实现类或扩展抽象类，可以轻松地扩展系统功能。

- **维护性（Maintainability）**：由于抽象和实现部分分离，所以修改其中一部分不会影响另一部分，使代码更易于维护。

### 桥接模式的实例：

考虑一个绘图应用程序，它可以在不同的操作系统上运行，并支持不同的图形渲染器。在这种情况下，可以使用桥接模式将绘图抽象和图形渲染器分离，以便可以独立地添加新的绘图抽象和图形渲染器。

```cpp
#include <iostream>

// Implementor Interface
class Renderer {
public:
    virtual void render() = 0;
};

// Concrete Implementor
class OpenGLRenderer : public Renderer {
public:
    void render() override {
        std::cout << "Rendering with OpenGL" << std::endl;
    }
};

// Concrete Implementor
class DirectXRenderer : public Renderer {
public:
    void render() override {
        std::cout << "Rendering with DirectX" << std::endl;
    }
};

// Abstraction
class Shape {
protected:
    Renderer* renderer; // Bridge Interface

public:
    Shape(Renderer* renderer) : renderer(renderer) {}

    virtual void draw() = 0;
};

// Refined Abstraction
class Circle : public Shape {
public:
    Circle(Renderer* renderer) : Shape(renderer) {}

    void draw() override {
        std::cout << "Drawing Circle ";
        renderer->render();
    }
};

// Refined Abstraction
class Square : public Shape {
public:
    Square(Renderer* renderer) : Shape(renderer) {}

    void draw() override {
        std::cout << "Drawing Square ";
        renderer->render();
    }
};

int main() {
    Renderer* openglRenderer = new OpenGLRenderer();
    Renderer* directxRenderer = new DirectXRenderer();

    Shape* circle = new Circle(openglRenderer);
    Shape* square = new Square(directxRenderer);

    circle->draw(); // Drawing Circle Rendering with OpenGL
    square->draw(); // Drawing Square Rendering with DirectX

    delete openglRenderer;
    delete directxRenderer;
    delete circle;
    delete square;

    return 0;
}
```

在这个示例中，`Shape` 是抽象类，`Renderer` 是实现类接口。`Circle` 和 `Square` 是扩充抽象类，它们分别继承自 `Shape`。`OpenGLRenderer` 和 `DirectXRenderer` 是具体实现类，它们分别实现了 `Renderer` 接口。通过这种方式，我们可以在不修改 `Circle` 和 `Square` 类的情况下，轻松地切换渲染器。

## 适配器模式
适配器模式
适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。

介绍
意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

如何解决：继承或依赖（推荐）。

关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。

应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。

优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

实现
我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。

我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。

我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。

AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo 类使用 AudioPlayer 类来播放各种格式。

code见文件

对象适配器模式（Object Adapter Pattern）：
在对象适配器模式中，适配器类通过持有（组合）被适配者对象的实例来实现适配。适配器类实现目标接口，并在内部调用被适配者对象的方法。这种方式使得适配器类与被适配者对象解耦，提高了灵活性。




## 原型模式

**原型模式**

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

介绍
意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

主要解决：在运行期建立和删除原型。

何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。

关键代码： 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。

优点： 1、性能提高。 2、逃避构造函数的约束。

缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。

## 建造者模式




## 工厂模式
工厂模式
工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。

工厂模式属于创建型模式，它在创建对象时提供了一种封装机制，将实际创建对象的代码与使用代码分离。

介绍
意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

主要解决：主要解决接口选择的问题。

何时使用：我们明确地计划不同条件下创建不同实例时。

如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。

关键代码：创建过程在其子类执行。

应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、在 Hibernate 中，如果需要更换数据库，工厂模式同样发挥了作用。只需简单地更改方言（Dialect）和数据库驱动（Driver），就能够实现对不同数据库的切换。

**优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。**

**缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。**

使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

工厂模式包含以下几个核心角色：

抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。
具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。
抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。
具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。



例子：

工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种封装对象创建过程的方法，以便在不暴露对象实例化逻辑的情况下创建对象。工厂模式通过定义一个公共的接口来创建对象，而具体的对象实例化过程由具体的工厂类来负责。

### 结构

工厂模式通常包含以下几个主要角色：

1. **产品（Product）**：定义了工厂模式所创建的对象的接口。可以是一个抽象类或者接口，也可以是一个具体的类。

2. **具体产品（Concrete Product）**：实现了产品接口的具体类，是工厂模式所创建的对象。

3. **工厂（Factory）**：负责创建产品对象的类，它通常包含一个工厂方法，该方法根据客户端的请求来创建具体的产品对象。

4. **客户端（Client）**：使用工厂模式创建对象的类。客户端通过调用工厂方法来获取所需的产品对象，而无需直接实例化具体的产品对象。

### 工作原理

工厂模式的工作原理如下：

1. 客户端向工厂发送请求，请求某种产品。
   
2. 工厂接收到请求后，根据请求的信息选择合适的产品，并创建该产品对象。
   
3. 工厂将创建的产品对象返回给客户端。

### 实例

假设我们有一个汽车制造厂，该厂生产不同类型的汽车，比如轿车和卡车。我们可以使用工厂模式来实现这个场景。

```cpp
#include <iostream>
#include <string>

// 产品接口
class Car {
public:
    virtual void drive() = 0;
};

// 具体产品
class Sedan : public Car {
public:
    void drive() override {
        std::cout << "Driving Sedan" << std::endl;
    }
};

class Truck : public Car {
public:
    void drive() override {
        std::cout << "Driving Truck" << std::endl;
    }
};

// 工厂接口
class CarFactory {
public:
    virtual Car* createCar() = 0;
};

// 具体工厂
class SedanFactory : public CarFactory {
public:
    Car* createCar() override {
        return new Sedan();
    }
};

class TruckFactory : public CarFactory {
public:
    Car* createCar() override {
        return new Truck();
    }
};

// 客户端
int main() {
    CarFactory* sedanFactory = new SedanFactory();
    Car* sedan = sedanFactory->createCar();
    sedan->drive();

    CarFactory* truckFactory = new TruckFactory();
    Car* truck = truckFactory->createCar();
    truck->drive();

    delete sedan;
    delete truck;
    delete sedanFactory;
    delete truckFactory;

    return 0;
}
```

在这个示例中，`Car` 是产品接口，定义了汽车的共同行为。`Sedan` 和 `Truck` 是具体产品，实现了 `Car` 接口，分别表示轿车和卡车。`CarFactory` 是工厂接口，定义了创建汽车的方法。`SedanFactory` 和 `TruckFactory` 是具体工厂，分别负责创建轿车和卡车对象。在 `main()` 函数中，我们创建了轿车和卡车的工厂对象，并使用工厂对象创建了具体的汽车对象。

工厂模式使得客户端代码与具体产品类解耦，客户端无需了解具体的产品类，只需要与工厂接口进行交互即可获取所需的产品对象。这种模式在需要根据条件来动态创建对象时特别有用，可以有效地提高代码的灵活性和可维护性。




### 工厂模式优缺点 注意的地方

## 观察者模式
观察者模式
观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

介绍
意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

如何解决：使用面向对象技术，可以将这种依赖关系弱化。

关键代码：在抽象类里有一个 ArrayList 存放观察者们。

应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

使用场景：

一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
一个对象必须通知其他对象，而并不知道这些对象是谁。
需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。
注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。

观察者模式包含以下几个核心角色：

主题（Subject）：也称为被观察者或可观察者，它是具有状态的对象，并维护着一个观察者列表。主题提供了添加、删除和通知观察者的方法。
观察者（Observer）：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。
具体主题（Concrete Subject）：具体主题是主题的具体实现类。它维护着观察者列表，并在状态发生改变时通知观察者。
具体观察者（Concrete Observer）：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作。
观察者模式通过将主题和观察者解耦，实现了对象之间的松耦合。当主题的状态发生改变时，所有依赖于它的观察者都会收到通知并进行相应的更新。


code:


观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，其所有依赖者（观察者）都会自动收到通知并更新。观察者模式也被称为发布-订阅模式。

### 结构

观察者模式包含以下几个关键角色：

1. **主题（Subject）**：也称为被观察者或可观察对象，它维护一系列观察者对象的列表，并提供了添加、删除和通知观察者的方法。

2. **观察者（Observer）**：定义了一个更新的接口，当接收到主题的通知时被调用，以便观察者可以获取主题的最新状态。

3. **具体主题（Concrete Subject）**：实现了主题接口的具体类，它负责维护自身状态，并在状态发生变化时通知所有观察者。

4. **具体观察者（Concrete Observer）**：实现了观察者接口的具体类，它注册到具体主题中，并在接收到通知时更新自身状态。

### 工作原理

观察者模式的工作原理如下：

1. 主题对象维护一组观察者对象的列表。

2. 观察者对象可以注册到主题对象中，也可以从主题对象中取消注册。

3. 当主题对象的状态发生变化时，它会遍历观察者列表，调用每个观察者的更新方法。

4. 每个观察者在接收到更新通知后，根据主题的状态进行相应的处理。

### 实例

让我们通过一个简单的例子来说明观察者模式。假设我们有一个气象站应用，它可以监测气温的变化，并通知注册的观察者。

```cpp
#include <iostream>
#include <vector>
// 四大核心角色带入了

// 观察者接口
class Observer {
public:
    virtual void update(float temperature) = 0;
};

// 主题接口
class Subject {
public:
    virtual void registerObserver(Observer* observer) = 0;
    virtual void removeObserver(Observer* observer) = 0;
    virtual void notifyObservers() = 0;
};

// 具体主题
class WeatherStation : public Subject {
private:
    float temperature;
    std::vector<Observer*> observers;

public:
    void registerObserver(Observer* observer) override {
        observers.push_back(observer);
    }

    void removeObserver(Observer* observer) override {
        auto it = std::find(observers.begin(), observers.end(), observer);
        if (it != observers.end()) {
            observers.erase(it);
        }
    }

    void notifyObservers() override {
        for (Observer* observer : observers) {
            observer->update(temperature);
        }
    }

    void setTemperature(float temp) {
        temperature = temp;
        notifyObservers();
    }
};

// 具体观察者
class Display : public Observer {
public:
    void update(float temperature) override {
        std::cout << "Temperature is: " << temperature << std::endl;
    }
};

int main() {
    WeatherStation weatherStation;
    Display display1, display2;

    weatherStation.registerObserver(&display1);
    weatherStation.registerObserver(&display2);

    weatherStation.setTemperature(25.5);
    weatherStation.setTemperature(30.0);

    return 0;
}
```

在这个示例中，`Observer` 是观察者接口，定义了一个更新方法 `update()`。`Subject` 是主题接口，定义了注册、移除和通知观察者的方法。`WeatherStation` 是具体主题，负责维护温度数据，并在温度发生变化时通知观察者。`Display` 是具体观察者，实现了 `Observer` 接口，在接收到温度变化通知后更新显示。

观察者模式使得主题和观察者之间解耦，主题无需知道观察者的具体实现，而只需发送通知即可。这种模式在需要多个对象对同一事件进行响应的情况下特别有用，可以降低对象之间的耦合性，提高系统的灵活性和可维护性。

## 建造者模式


建造者模式
建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

介绍
意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

何时使用：一些基本部件不会变，而其组合经常变化的时候。

如何解决：将变与不变分离开。

关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。

优点：

分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。
可以更好地控制构建过程，隐藏具体构建细节。
代码复用性高，可以在不同的构建过程中重复使用相同的建造者。
缺点：

如果产品的属性较少，建造者模式可能会导致代码冗余。
建造者模式增加了系统的类和对象数量。
使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。

建造者模式在创建复杂对象时非常有用，特别是当对象的构建过程涉及多个步骤或参数时。它可以提供更好的灵活性和可维护性，同时使得代码更加清晰可读。
注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。